---
title: "Population genetic structure of shallow and mesophotic *Montastraea cavernosa* in the Florida Keys"
author: "Alexis Sturm -- lexie.sturm@gmail.com and Ryan Eckert-- ryan.j.eckert@gmail.com"
date: "7/29/2020"
output:
  html_document:
    theme: flatly
    toc: yes
    toc_depth: 4
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, fig.align = 'left')
knitr::opts_knit$set(root.dir = '../data')
options(width = 88, scipen = 4)
```

***

# About this document
***  
All analyses were performed in R version 3.6.2.
This is the code that accompanies the publication XXX. Here you will find all the code to repeat the statistical analyses performed in R and the figures created for the manuscript. The accompanying library preparation protocol and bioinformatic walkthrough can be found by clicking on the links.

If you have any issues or questions about the code please feel free to send an email to lexie.sturm@gmail.com.

***

# Basic setup of R environment
***
## Loading required packages
Make sure to set the working directory:
`setwd("~/path/to/directory/with/data")`

```{r, set working directory}
setwd('../data')
```

For the following analyses we will require the use of multiple different R packages, we can use the package *pacman* to quickly load them.
```{r, load packages, include = TRUE, message = FALSE, warning = FALSE, results = 'hide'}
if (!require("pacman")) install.packages("pacman")
pacman::p_load("adegenet", "dendextend", "flextable", "gdata", "ggdendro", "hierfstat", "Imap", "kableExtra", "paletteer", "patchwork", "officer", "poppr", "RColorBrewer", "reshape2", "StAMPP", "tidyverse", "vcfR", "vegan", "WGCNA", "boa", "plyr")
```

# Figures and analyses
## Dendrogram with Clones
```{r, Dendrogram With Clones, fig.dim = c(13, 4.75)}
cloneBams = read.table("sampleList")[,1] # list of bam files
cloneMa = as.matrix(read.table("fkMcavClones.ibsMat")) # reads in IBS matrix produced by ANGSD
dimnames(cloneMa) = list(cloneBams,cloneBams)
clonesHc = hclust(as.dist(cloneMa),"ave")

cloneMeta = read.csv("inds2pops.csv") # list of bams files and their populations
clonePops = cloneMeta$pop
cloneDepth = cloneMeta$depth

cloneDend = cloneMa %>% as.dist() %>% hclust(.,"ave") %>% as.dendrogram()
cloneDData = cloneDend %>% dendro_data()

# Making the branches hang shorter so we can easily see clonal groups
cloneDData$segments$yend2 = cloneDData$segments$yend
for(i in 1:nrow(cloneDData$segments)) {
  if (cloneDData$segments$yend2[i] == 0) {
    cloneDData$segments$yend2[i] = (cloneDData$segments$y[i] - 0.03)}}

cloneDendPoints = cloneDData$labels
cloneDendPoints$pop = clonePops[order.dendrogram(cloneDend)]
cloneDendPoints$depth=cloneDepth[order.dendrogram(cloneDend)]
rownames(cloneDendPoints) = cloneDendPoints$label

# Making points at the leaves to place symbols for populations
point = as.vector(NA)
for(i in 1:nrow(cloneDData$segments)) {
  if (cloneDData$segments$yend[i] == 0) {
    point[i] = cloneDData$segments$y[i] - 0.03
  } else {
    point[i] = NA}}

cloneDendPoints$y = point[!is.na(point)]

techReps = c("009-1", "009-2", "009-3", "159-1", "159-2", "159-3", "171-1", "171-2", "171-3")
cloneDendPoints$depth = factor(cloneDendPoints$depth,levels(cloneDendPoints$depth)[c(2,1)])

cloneDendA = ggplot() +
  geom_segment(data = segment(cloneDData), aes(x = x, y = y, xend = xend, yend = yend2), size = 0.5) +
  geom_point(data = cloneDendPoints, aes(x = x, y = y, fill = pop, shape = depth), size = 4, stroke = 0.25) +
  #scale_fill_brewer(palette = "Dark2", name = "Population") +
  scale_fill_paletteer_d("LaCroixColoR::PassionFruit", breaks=c("TER-South","TER-North","Lower Keys", "Upper Keys"), name= "Population")+
  scale_shape_manual(values=c(24, 25), breaks=c("Shallow","Mesophotic"), name="Depth Zone")+
  #geom_hline(yintercept = 0.1, color = "red", lty = 5, size = 0.75) + # creating a dashed line to indicate a clonal distance threshold
  geom_text(data = subset(cloneDendPoints, subset = label %in% techReps), aes(x = x, y = (y - .015), label = label), angle = 90) + # spacing technical replicates further from leaf
  geom_text(data = subset(cloneDendPoints, subset = !label %in% techReps), aes(x = x, y = (y - .010), label = label), angle = 90) +
  geom_text(data = subset(cloneDendPoints, subset = label %in% c("218", "223", "221", "226")), aes(x = (x + .5), y = (y - .018), label = "*"), angle = 90, size = 6) + # labeling natural clones with asterisks
  #coord_cartesian(xlim = c(3, 84)) +
  labs(y = "Genetic distance (1 - IBS)") +
  guides(fill = guide_legend(override.aes = list(shape = 21)))+
  theme_classic()

cloneDend = cloneDendA + theme(
  axis.title.x = element_blank(),
  axis.text.x = element_blank(),
  axis.line.x = element_blank(),
  axis.ticks.x = element_blank(),
  axis.title.y = element_text(size = 12, color = "black", angle = 90),
  axis.text.y = element_text(size = 10, color = "black"),
  axis.line.y = element_line(),
  axis.ticks.y = element_line(),
  panel.grid = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  plot.background = element_blank(),
  legend.key = element_blank(),
  legend.title = element_text(size = 12),
  legend.text = element_text(size = 10),
  legend.position = "left")

cloneDend

ggsave("../figures/cloneDend.tiff", plot = cloneDend, height = 4.75, width = 30, units = "in", dpi = 300)
```
##Dendrogram no Clones
```{r, Dendrogram no Clones, fig.dim = c(13, 4.75)}
bamsNoClones = read.table("bamsNoClones")[,1] # list of bam file
snpMa = as.matrix(read.table("fkMcavNoClones.ibsMat"))
snpI2P = read.csv("inds2popsNoClones.csv") # 2-column tab-delimited table of individual assignments to populations; must be in the same order as samples in the bam list or vcf file.
row.names(snpI2P) = snpI2P[,1]

snpDend = snpMa %>% scale %>% dist %>%
  hclust %>% as.dendrogram

snpDData = dendro_data(snpDend)
snpDendPoints = snpDData$labels
snpDendPoints$site = snpI2P[,2][order.dendrogram(snpDend)]
snpDendPoints$depth = snpI2P[,3][order.dendrogram(snpDend)]
snpDendPoints$depth = factor(snpDendPoints$depth, levels(snpDendPoints$depth)[c(2,1)])

snpDendA = ggplot() +
  geom_segment(data = segment(snpDData), aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_point(data = snpDendPoints, aes(x = x, y = y, fill = site, shape = depth), size = 5) +
  scale_shape_manual(values=c(24, 25), breaks=c("Shallow","Mesophotic"), name="Depth Zone")+
  scale_fill_paletteer_d("LaCroixColoR::PassionFruit", breaks=c("TER-South","TER-North","Lower Keys", "Upper Keys"), name= "Population")+
  guides(fill = guide_legend(override.aes = list(shape = 21)))+
  theme_dendro()

snpDend = snpDendA + theme(
  legend.key = element_blank(),
  legend.title = element_text(size = 14),
  legend.text = element_text(size = 12))

snpDend

ggsave("../figures/snpDend.tiff", plot = snpDend, height = 4.75, width = 35, units = "in", dpi = 300)
```

## Heterozygosity
```{r, hetero}
hetero=read.csv("sampleHeterozygosity.csv")
heteroStat <- ddply(hetero, c("popdepth"), summarise,
               N    = length(Heterozygosity),
               mean = mean(Heterozygosity),
               sd   = sd(Heterozygosity),
               se   = sd / sqrt(N))
max(heteroStat$mean, na.rm = TRUE)
```
## PCoA with IBS
```{r, PCoA with IBS}
snpMa = as.matrix(read.table("fkMcavNoClones.ibsMat"))
fkMds = cmdscale(snpMa, eig = TRUE, x.ret = TRUE)

# Determine percent variation captured on each axis
# Calculate the eigenvalues so later we can figure out % variation shown on each Principal Coordinate
fkSnpPcoaVar = round(fkMds$eig/sum(fkMds$eig)*100, 1)
fkSnpPcoaVar

# Format data to plot
fkSnpPcoaValues = fkMds$points
fkSnpPcoaValues

snpI2P = read.csv("inds2popsNoClones.csv") # 2-column tab-delimited table of individual assignments to populations; must be in the same order as samples in the bam list or vcf file.
row.names(snpI2P) = snpI2P[,1]
fkSnpPcoaValues=cbind(snpI2P, fkSnpPcoaValues)
fkSnpPcoaValues =as.data.frame(fkSnpPcoaValues, sample = rownames(fkSnpPcoaValues))
colnames(fkSnpPcoaValues)[5] <- "PCo1"
colnames(fkSnpPcoaValues)[6] <- "PCo2"
fkSnpPcoaValues

snpPCoA = merge(fkSnpPcoaValues, aggregate(cbind(mean.x=PCo1,mean.y=PCo2)~popsite, fkSnpPcoaValues, mean), by="popsite")

snpPCoA$depth = factor(snpPCoA$depth, levels(snpPCoA$depth)[c(2,1)])

# SNP PCoA biplot
fkSnpPcoaPlotA = ggplot(snpPCoA, aes(x = PCo1, y = PCo2, color = pop, fill = pop, shape = depth, linetype = depth)) +
  geom_hline(yintercept = 0, color = "gray90", size = 0.5) +
  geom_vline(xintercept = 0, color = "gray90", size = 0.5) +
  stat_ellipse(data = subset(snpPCoA, type = "t", geom = "polygon", alpha = 0.1)) + #ellipse
  scale_linetype_manual(values=c(1,2), breaks=c("Shallow","Mesophotic"), name = "Depth Zone")+
  geom_point(aes(x = PCo1, y = PCo2, shape = depth), size = 3, alpha = 0.3, show.legend = FALSE, guide=FALSE) + #individual's points indicated by circles
  scale_shape_manual(values = c(24,25), breaks=c("Shallow","Mesophotic"), name = "Depth Zone") +
  geom_point(aes(x = mean.x, y = mean.y, shape = depth), size = 5, color = "black") + #population centroids indicated by triangles
  scale_fill_paletteer_d("LaCroixColoR::PassionFruit", breaks=c("TER-South","TER-North","Lower Keys", "Upper Keys"), name= "Population")+
  scale_color_paletteer_d("LaCroixColoR::PassionFruit", breaks=c("TER-South","TER-North","Lower Keys", "Upper Keys"), name = " Population", guide=FALSE) +
  xlab(paste ("PCo 1 (", fkSnpPcoaVar[1],"%)", sep = "")) + #Prints percent variation explained by first axis
  ylab(paste ("PCo 2 (", fkSnpPcoaVar[2],"%)", sep = "")) + #Prints percent variation explained by second axis
  guides(shape = guide_legend(order = 2), linetype = guide_legend(order = 3), fill = guide_legend(override.aes = list(shape = 22, size = 4, color = NA), order = 1))+
  theme_bw()

fkSnpPcoaPlot = fkSnpPcoaPlotA +
  theme(axis.title.x = element_text(color = "black", size = 10),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_blank(),
        axis.title.y = element_text(color = "black", size = 10),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line.y = element_blank(),
        legend.position = "left",
        panel.border = element_rect(color = "black", size = 1.2),
        panel.background = element_rect(fill = "white"),
        plot.background = element_rect(fill = "white"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())



fkSnpPcoaPlot

ggsave("../figures/fkSnpPcoaPlot.tiff", plot = fkSnpPcoaPlot, height = 5, width = 7, units = "in", dpi = 300)
```

## AMOVA and Pairwise Fst
```{r, AMOVA and Pairwise Fst, fig.width = 13.4, fig.height = 5.9}
fkVcf = read.vcfR("fkMcavNoClonesRenamed.vcf.gz")
fkGenlightPopDepth = vcfR2genlight(fkVcf, n.cores = 2) # Converts the vcf file into a file format that poppr uses the "genlight" format
locNames(fkGenlightPopDepth) = paste(fkVcf@fix[,1],fkVcf@fix[,2],sep="_")
popData = read.csv("inds2popsNoClonesPopDepth.csv") # Reads in population data for each sample

strata(fkGenlightPopDepth) = data.frame(popData)
setPop(fkGenlightPopDepth) = ~popdepth
amova <- poppr.amova(fkGenlightPopDepth, ~popdepth) #Runs AMOVA
amova
set.seed(1999)
amovasignif <- randtest(amova, nrepet = 99) #Calculates significance levels of the AMOVA with 99 permutations
amovasignif

fkGenlightPopDepth$pop = factor(fkGenlightPopDepth$pop, levels(fkGenlightPopDepth$pop)[c(4,3,2,1,5,6,8,7)])

set.seed(694)
fk.fst <- stamppFst(fkGenlightPopDepth, nboots = 99, percent = 95, nclusters = 4) #99 permutations
fk.fst$Fsts
fk.fst$Pvalues

pop.order <- c("TER-South-Shallow", "TER-South-Mesophotic",  "TER-North-Shallow", "TER-North-Mesophotic", "Lower Keys-Shallow", "Lower Keys-Mesophotic", "Upper Keys-Shallow", "Upper Keys-Mesophotic")

# reads in fst matrix
snpFstMa <- as.matrix(fk.fst$Fsts)
upperTriangle(snpFstMa, byrow=TRUE) <- lowerTriangle(snpFstMa)
snpFstMa <- snpFstMa[,pop.order] %>%
  .[pop.order,]
snpFstMa[upper.tri(snpFstMa)] <- NA
snpFstMa <- as.data.frame(snpFstMa)

snpFstMa$Pop = factor(row.names(snpFstMa), levels = unique(pop.order))

snpQMa <- as.matrix(fk.fst$Pvalues)
upperTriangle(snpQMa, byrow=TRUE) <- lowerTriangle(snpQMa)
snpQMa <- snpQMa[,pop.order] %>%
  .[pop.order,]
snpQMa[upper.tri(snpQMa)] <- NA
snpQMa <- as.data.frame(snpQMa)
snpQMa$Pop = factor(row.names(snpQMa), levels = unique(pop.order))

snpFstMa$Pop = factor(row.names(snpFstMa), levels = unique(pop.order))
snpFst = melt(snpFstMa, id.vars = "Pop", value.name = "Fst", variable.name = "Pop2", na.rm = TRUE)
snpFst = snpFst[snpFst$Pop != snpFst$Pop2,]
snpFst$Fst = round(snpFst$Fst, 3)
snpFst = snpFst %>% mutate(Fst = replace(Fst, Fst < 0, 0))
head(snpFst)

snpQ = melt(snpQMa, id.vars = "Pop", value.name = "Pval", variable.name = "Pop2", na.rm = TRUE)
snpQ = snpQ[snpQ$Pop != snpQ$Pop2,]
snpQ$Qval = p.adjust(snpQ$Pval, method = "BH")
head(snpQ)

snpHeatmapA = ggplot(data = snpFst, aes(Pop, Pop2, fill = Fst))+
  geom_tile(color = "white")+
  scale_fill_gradient2(low = "white", high = "red", midpoint = 0, limit = c(0, 0.1),
                       space = "Lab", name = expression(paste(italic("F")[ST])))+
  geom_text(data = snpFst, aes(Pop, Pop2, label = Fst), color = ifelse(snpQ$Qval <= 0.05,"black", "darkgrey"), size = ifelse(snpQ$Qval < 0.05, 6, 5)) +
  guides(fill=guide_colorbar(barwidth = 1, barheight = 12, title.position = "top", title.hjust = 0.5))+                     
  scale_y_discrete(position = "right")+
  scale_x_discrete(labels = str_wrap(snpFst$Pop, width = 6)) +
  #ggtitle("   SNP") +
  theme_minimal()

snpHeatmap = snpHeatmapA + theme(
  axis.text.x = element_text(vjust = 1, size = 16, hjust = 0.5, color = "black"),
  axis.text.y = element_text(size = 16, color = "black"),
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  legend.position = "right",
  legend.direction = "vertical",
  legend.title = element_text(size = 16),
  legend.text = element_text(size = 14),
  plot.title = element_text(size = 16)
)

snpHeatmap

ggsave("../figures/snpHeatMap.tiff", plot = snpHeatmap, width = 34, height = 15, units = "cm", dpi = 300)
```
## ADMIXTURE Plot
```{r, ADMIXTURE}
df <- read.csv("fkMcavNoClones_k4.csv")
df$sample <- factor(df$sample, levels= df$sample[order(-df$cluster4, df$cluster2)])

mdat = melt(df, id.vars=c("sample", "pop"), variable.name="Ancestry", value.name="Fraction")

mdat$pop = factor(mdat$pop, levels(mdat$pop)[c(6,5,4,3,2,1,8,7)])

p = ggplot(mdat, aes(x=sample, y=Fraction, fill=Ancestry)) +
  geom_bar(stat="identity", position="stack") +
  facet_grid(. ~ pop, drop=TRUE, space="free", scales="free")

#col2 = c("turquoise", "blue", "green", "purple")

#names(col2) = levels(mdat$Ancestry)

p2 = ggplot(mdat, aes(x=sample, y=Fraction, fill=Ancestry, order=sample)) +
  geom_bar(stat="identity", position="fill", width=1, colour="grey25") +
  facet_grid(~pop, scales = "free", switch = "x", space = "free") +
  labs(x = "Population", y = "Ancestry") +
  ggtitle("K4 NGSAdmixture Plot") +
  theme(plot.title = element_text(hjust = 0.5),
  panel.grid=element_blank(),
  panel.background=element_rect(fill=NA, colour="grey25"),
  panel.spacing.x=grid:::unit(0, "lines"),
  panel.border = element_rect(fill=NA,color="black", size=2, linetype="solid"),
  #axis.text.x=element_text(size=12, angle=90)
  axis.text.x = element_blank(),
  axis.ticks.x=element_blank(),
  strip.background=element_blank(),
  strip.text=element_text(size=12, angle=90),
  legend.key=element_blank(),
  legend.position = "none",
  legend.title = element_blank()) +
  scale_x_discrete(expand=c(0, 0)) +
  scale_y_continuous(expand=c(0, 0)) +
  scale_fill_manual(values = brewer.pal(name = "YlGnBu", n = 4), name = "Cluster") +
  guides(fill=guide_legend(override.aes=list(colour=NULL)))

p2

ggsave("../figures/admixturePlot.tiff", plot = p2, width = 30, height = 15, units = "cm", dpi = 300)
```

## Zoox and Depth
```{r, zooxDepth, eval = F}
install.packages("moments")
library(moments)
zooxHostProportions=read.csv("zooxMcavRatio.csv", header=TRUE)
skewness(zooxHostProportions$zooxReadRatio, na.rm = TRUE)
zooxHostProportions$zooxReadRatio <- log10(zooxHostProportions$zooxReadRatio)
skewness(zooxHostProportions$zooxReadRatio, na.rm = TRUE)

zooxDepthPlot=ggplot(zooxHostProportions, aes(x=depth, y=zooxReadRatio)) +
  geom_point()+
  geom_smooth(method = "lm")

zooxDepthPlot

install.packages("car")
library(car)

leveneTest(zooxReadRatio ~ site*depthZone, data = zooxHostProportions)
res.aov3 <- aov(zooxReadRatio ~ site * depthZone, data = zooxHostProportions)
shapiro.test(zooxHostProportions$zooxReadRatio)
residualplot=plot(res.aov3, 2)
zooxAnova <- aov(zooxReadRatio ~ site * depthZone, data = zooxHostProportions)
Anova(zooxAnova, type = "III")
install.packages("multcompView")
library(multcompView)
install.packages("lsmeans")
library(lsmeans)

lsmeans = lsmeans::lsmeans ### Uses the lsmeans function
                           ###  from the lsmeans package,
                           ###  not from the lmerTest package

leastsquare = lsmeans(zooxAnova,
                      pairwise ~ site:depthZone,
                      adjust="tukey")


zooxBoxPlot=ggplot(zooxHostProportions, aes(x=site, y=zooxReadRatio, fill=depthZone)) +
  geom_boxplot()

zooxBoxPlot


#Zoox Plot

dfZoox = read.csv("zooxCommunity.csv")

dfZoox$Population = factor(dfZoox$Population, levels = levels(dfZoox$Population)[c(6,5,4,3,2,1,8,7)])

dfZoox = dfZoox[order(dfZoox$Population),]
dfZoox$Order = c(1:nrow(dfZoox))

zDat = melt(dfZoox, id.vars = c("Sample", "Population", "Order"), variable.name = "Symbiont", value.name = "Fraction")
colPalZoox = brewer.pal(4, "BrBG")
names(colPalZoox) = levels(zDat$Symbiont)

zooxPlotA = ggplot(data = zDat, aes(x = Order, y = Fraction, fill = Symbiont, order = Order)) +
  geom_bar(stat = "identity", position = "stack", colour = "grey25", width = 1) +
  xlab("Population") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), labels = function(x) paste0(x*100, "%")) +
  scale_fill_manual(values = colPalZoox, name = "Symbiodiniaceae genus") +
  coord_cartesian(ylim = c(-.01,1.01)) +
  facet_grid(.~fct_inorder(Population), drop=TRUE, scales = "free", switch = "x", space = "free") +
  theme_bw()

zooxPlot = zooxPlotA + theme(plot.title = element_text(hjust = 0.5),
  panel.grid=element_blank(),
  panel.background=element_rect(fill=NA, colour="grey25"),
  panel.spacing.x=grid:::unit(0, "lines"),
  panel.border = element_rect(fill=NA,color="black", size=2, linetype="solid"),
  #axis.text.x=element_text(size=12, angle=90)
  axis.text.x = element_blank(),
  axis.ticks.x=element_blank(),
  strip.background=element_blank(),
  strip.text=element_text(size=12, angle=90),
  legend.key=element_blank(),
  legend.position = "right",
  legend.title = element_blank(),
  legend.text = element_text(face = "italic"))
zooxPlot

ggsave("../figures/zooxPlot.tiff", plot = zooxPlot, width = 30, height = 15, units = "cm", dpi = 300)
```

```{r, mantelTest}
# Isolation by distance
ReplaceLowerOrUpperTriangle = function(m, triangle.to.replace) {
  if (nrow(m) != ncol(m))
    stop("Supplied matrix must be square.")
  if (tolower(triangle.to.replace) == "lower")
    tri = lower.tri(m)
  else if (tolower(triangle.to.replace) == "upper")
    tri = upper.tri(m)
  else
    stop("triangle.to.replace must be set to 'lower' or 'upper'.")
  m[tri] = t(m)[tri]
  return(m)
}
  # If triangle.to.replace="lower", replaces the lower triangle of a square matrix with its upper triangle.
  # If triangle.to.replace="upper", replaces the upper triangle of a square matrix with its lower triangle.

GeoDistanceInMetresMatrix = function(df.geopoints) {
  # Returns a matrix (M) of distances between geographic points. M[i,j] = M[j,i] = Distance between (df.geopoints$lat[i], df.geopoints$lon[i]) and (df.geopoints$lat[j], df.geopoints$lon[j]). The row and column names are given by df.geopoints$name.
  
  GeoDistanceInMetres = function(g1, g2) {
    # Returns a vector of distances. (But if g1$index > g2$index, returns zero.) The 1st value in the returned vector is the distance between g1[[1]] and g2[[1]]. The 2nd value in the returned vector is the distance between g1[[2]] and g2[[2]]. Etc. Each g1[[x]] or g2[[x]] must be a list with named elements "index", "lat" and "lon". E.g. g1 = list(list("index"=1, "lat"=12.1, "lon"=10.1), list("index"=3, "lat"=12.1, "lon"=13.2))
    
    DistM = function(g1, g2) {
      require("Imap")
      return(ifelse(
        g1$index > g2$index,
        0,
        gdist(lat.1 = g1$lat, lon.1 = g1$lon, lat.2 = g2$lat, lon.2 = g2$lon, units = "m")))
    }
    return(mapply(DistM, g1, g2))
  }
  
  n.geopoints = nrow(df.geopoints)
  
  # The index column is used to ensure we only do calculations for the upper triangle of points
  df.geopoints$index = 1:n.geopoints
  
  # Create a list of lists
  list.geopoints = by(df.geopoints[, c("index", "lat", "lon")], 1:n.geopoints, function(x) {
    return(list(x))
  })
  
  # Get a matrix of distances (in metres)
  mat.distances = ReplaceLowerOrUpperTriangle(outer(list.geopoints, list.geopoints, GeoDistanceInMetres), "lower")
  
  # Set the row and column names
  rownames(mat.distances) = df.geopoints$name
  colnames(mat.distances) = df.geopoints$name
  return(mat.distances)}

snpNeiDist = as.dist(stamppNeisD(fkGenlightPopDepth, pop = TRUE), diag = F)
coords = read.csv("fkXYcoords.csv", header=TRUE) # tab-separated file for all pops
dGeo = as.dist(GeoDistanceInMetresMatrix(coords)/1000, diag = T)

# Test IBD
set.seed(694)
snpIBD = mantel.randtest(dGeo,snpNeiDist)
snpIBD
snpNei =  melt(as.matrix(snpNeiDist), varnames = c("row", "col"), value.name = "nei")
snpNei = snpNei[snpNei$row != snpNei$col,]

geo = melt(as.matrix(dGeo), varnames = c("row", "col"), value.name = "geo")
geo = geo[geo$row != geo$col,]

snpMantelDF = data.frame(cbind(snpNei$nei, geo$geo))
colnames(snpMantelDF) = c("nei", "geo")

snpMantelA = ggplot(data = snpMantelDF, aes(x = geo, y = nei)) +
  scale_fill_gradientn(colors = paletteer_d("wesanderson::Zissou1")) +
  stat_density_2d(aes(fill = stat(density)), n = 300, contour = FALSE, geom = "raster") +
  geom_smooth(method = lm, col = "black", fill = "gray40", fullrange = TRUE) +
  geom_point(shape = 21, fill = "gray40") +
  scale_x_continuous(limits = c(0,1000), expand = c(0,0)) +
  scale_y_continuous(limits = c(0,0.15), breaks = seq(0,0.15, by = 0.05), expand = c(0,0)) +
  annotate("label", x = 775, y = 0.14325, 
           label = paste("r = ", round(snpIBD$obs, 3), "; p = ", snpIBD$pvalue), 
           size = 4, alpha = 0.6) +             
  labs(x = "Geographic distance (km)", y = expression(paste("Nei's genetic distance (",italic("D"),")"))) +
  ggtitle("SNP") +
  theme_bw()

snpMantel = snpMantelA + theme(
  axis.title.x = element_blank(),
  axis.text.x = element_text(size = 12, color = "black"),
  axis.ticks.x = element_line(color = "black"),
  axis.line.x = element_blank(),
  axis.title.y = element_text(color = "white"),
  axis.text.y = element_text(size = 12, color = "black"),
  axis.ticks.y = element_line(color = "black"),
  axis.line.y = element_blank(),
  panel.border = element_rect(size = 1.2, color = "black"),
  plot.margin = margin(0.2,0.5,0.1,0.1, unit = "cm"),
  legend.position = "none")

snpMantel
```

```{r, bayescanOutliers}
source('plot_R.r')

#install.packages("boa")
library(boa)
source('plot_R.r')
dat = read.table("fkMcav.baye_fst.txt",header=T)
head(dat)
table(dat[,"qval"]<0.1)
outs=which(dat[,"qval"]<0.1)
plot_bayescan("fkMcav.baye_fst.txt",FDR=0.1,add_text=F,size=0.5,highlight=outs)

fkVcfOuts = read.vcfR("fkVcfOutliers.vcf.gz")
fkGenlightPopDepthOuts = vcfR2genlight(fkVcfOuts, n.cores = 2) # Converts the vcf file into a file format that poppr uses the "genlight" format
locNames(fkGenlightPopDepthOuts) = paste(fkVcfOuts@fix[,1],fkVcfOuts@fix[,2],sep="_")
popData = read.csv("inds2popsNoClonesPopDepth.csv") # Reads in population data for each sample
strata(fkGenlightPopDepthOuts) = data.frame(popData)
setPop(fkGenlightPopDepthOuts) = ~popdepth
amovaOuts <- poppr.amova(fkGenlightPopDepthOuts, ~popdepth) #Runs AMOVA
amovaOuts
set.seed(1999)
amovasignifOuts <- randtest(amovaOuts, nrepet = 99) #Calculates significance levels of the AMOVA with 99 permutations
amovasignifOuts

fkGenlightPopDepthOuts$pop = factor(fkGenlightPopDepthOuts$pop, levels(fkGenlightPopDepth$pop)[c(4,3,2,1,5,6,8,7)])

set.seed(694)
fk.fstOuts <- stamppFst(fkGenlightPopDepthOuts, nboots = 99, percent = 95, nclusters = 4) #99 permutations
fk.fstOuts$Fsts
fk.fstOuts$Pvalues

pop.order <- c("TER-South-Shallow", "TER-South-Mesophotic",  "TER-North-Shallow", "TER-North-Mesophotic", "Lower Keys-Shallow", "Lower Keys-Mesophotic", "Upper Keys-Shallow", "Upper Keys-Mesophotic")

# reads in fst matrix
snpFstMaOuts <- as.matrix(fk.fstOuts$Fsts)
upperTriangle(snpFstMaOuts, byrow=TRUE) <- lowerTriangle(snpFstMaOuts)
snpFstMaOuts <- snpFstMaOuts[,pop.order] %>%
  .[pop.order,]
snpFstMaOuts[upper.tri(snpFstMaOuts)] <- NA
snpFstMaOuts <- as.data.frame(snpFstMaOuts)

snpFstMaOuts$Pop = factor(row.names(snpFstMaOuts), levels = unique(pop.order))

snpQMaOuts <- as.matrix(fk.fstOuts$Pvalues)
upperTriangle(snpQMaOuts, byrow=TRUE) <- lowerTriangle(snpQMaOuts)
snpQMaOuts <- snpQMaOuts[,pop.order] %>%
  .[pop.order,]
snpQMaOuts[upper.tri(snpQMaOuts)] <- NA
snpQMaOuts <- as.data.frame(snpQMaOuts)
snpQMaOuts$Pop = factor(row.names(snpQMaOuts), levels = unique(pop.order))

snpFstMaOuts$Pop = factor(row.names(snpFstMaOuts), levels = unique(pop.order))
snpFstOuts = melt(snpFstMaOuts, id.vars = "Pop", value.name = "Fst", variable.name = "Pop2", na.rm = TRUE)
snpFstOuts = snpFstOuts[snpFstOuts$Pop != snpFstOuts$Pop2,]
snpFstOuts$Fst = round(snpFstOuts$Fst, 3)
snpFstOuts = snpFstOuts %>% mutate(Fst = replace(Fst, Fst < 0, 0))
head(snpFstOuts)

snpQOuts = melt(snpQMaOuts, id.vars = "Pop", value.name = "Pval", variable.name = "Pop2", na.rm = TRUE)
snpQOuts = snpQOuts[snpQOuts$Pop != snpQOuts$Pop2,]
snpQOuts$Qval = p.adjust(snpQOuts$Pval, method = "BH")
head(snpQOuts)

snpHeatmapAOuts = ggplot(data = snpFstOuts, aes(Pop, Pop2, fill = Fst))+
  geom_tile(color = "white")+
  scale_fill_gradient2(low = "white", high = "red", midpoint = 0, limit = c(0, 0.35),
                       space = "Lab", name = expression(paste(italic("F")[ST])))+
  geom_text(data = snpFstOuts, aes(Pop, Pop2, label = Fst), color = ifelse(snpQOuts$Qval <= 0.05,"black", "darkgrey"), size = ifelse(snpQOuts$Qval < 0.05, 6, 5)) +
  guides(fill=guide_colorbar(barwidth = 1, barheight = 12, title.position = "top", title.hjust = 0.5))+                     
  scale_y_discrete(position = "right")+
  scale_x_discrete(labels = str_wrap(snpFstOuts$Pop, width = 6)) +
  #ggtitle("   SNP") +
  theme_minimal()

snpHeatmapOuts = snpHeatmapAOuts + theme(
  axis.text.x = element_text(vjust = 1, size = 16, hjust = 0.5, color = "black"),
  axis.text.y = element_text(size = 16, color = "black"),
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  legend.position = "right",
  legend.direction = "vertical",
  legend.title = element_text(size = 16),
  legend.text = element_text(size = 14),
  plot.title = element_text(size = 16)
)

snpHeatmapOuts

ggsave("../figures/snpHeatMapOuts.tiff", plot = snpHeatmapOuts, width = 34, height = 15, units = "cm", dpi = 300)

###Neutral SNPs Only
fkVcfNeut = read.vcfR("fkVcfNeutral.vcf.gz")
fkGenlightPopDepthNeut = vcfR2genlight(fkVcfNeut, n.cores = 2) # Converts the vcf file into a file format that poppr uses the "genlight" format
locNames(fkGenlightPopDepthNeut) = paste(fkVcfNeut@fix[,1],fkVcfNeut@fix[,2],sep="_")
popData = read.csv("inds2popsNoClonesPopDepth.csv") # Reads in population data for each sample
strata(fkGenlightPopDepthNeut) = data.frame(popData)
setPop(fkGenlightPopDepthNeut) = ~popdepth
amovaNeut <- poppr.amova(fkGenlightPopDepthNeut, ~popdepth) #Runs AMOVA
amovaNeut
set.seed(1999)
amovasignifNeut <- randtest(amovaNeut, nrepet = 99) #Calculates significance levels of the AMOVA with 99 permutations
amovasignifNeut

fkGenlightPopDepthNeut$pop = factor(fkGenlightPopDepthNeut$pop, levels(fkGenlightPopDepth$pop)[c(4,3,2,1,5,6,8,7)])

set.seed(694)
fk.fstNeut <- stamppFst(fkGenlightPopDepthNeut, nboots = 99, percent = 95, nclusters = 4) #99 permutations
fk.fstNeut$Fsts
fk.fstNeut$Pvalues

pop.order <- c("TER-South-Shallow", "TER-South-Mesophotic",  "TER-North-Shallow", "TER-North-Mesophotic", "Lower Keys-Shallow", "Lower Keys-Mesophotic", "Upper Keys-Shallow", "Upper Keys-Mesophotic")

# reads in fst matrix
snpFstMaNeut <- as.matrix(fk.fstNeut$Fsts)
upperTriangle(snpFstMaNeut, byrow=TRUE) <- lowerTriangle(snpFstMaNeut)
snpFstMaNeut <- snpFstMaNeut[,pop.order] %>%
  .[pop.order,]
snpFstMaNeut[upper.tri(snpFstMaNeut)] <- NA
snpFstMaNeut <- as.data.frame(snpFstMaNeut)

snpFstMaNeut$Pop = factor(row.names(snpFstMaNeut), levels = unique(pop.order))

snpQMaNeut <- as.matrix(fk.fstNeut$Pvalues)
upperTriangle(snpQMaNeut, byrow=TRUE) <- lowerTriangle(snpQMaNeut)
snpQMaNeut <- snpQMaNeut[,pop.order] %>%
  .[pop.order,]
snpQMaNeut[upper.tri(snpQMaNeut)] <- NA
snpQMaNeut <- as.data.frame(snpQMaNeut)
snpQMaNeut$Pop = factor(row.names(snpQMaNeut), levels = unique(pop.order))

snpFstMaNeut$Pop = factor(row.names(snpFstMaNeut), levels = unique(pop.order))
snpFstNeut = melt(snpFstMaNeut, id.vars = "Pop", value.name = "Fst", variable.name = "Pop2", na.rm = TRUE)
snpFstNeut = snpFstNeut[snpFstNeut$Pop != snpFstNeut$Pop2,]
snpFstNeut$Fst = round(snpFstNeut$Fst, 3)
snpFstNeut = snpFstNeut %>% mutate(Fst = replace(Fst, Fst < 0, 0))
head(snpFstNeut)

snpQNeut = melt(snpQMaNeut, id.vars = "Pop", value.name = "Pval", variable.name = "Pop2", na.rm = TRUE)
snpQNeut = snpQNeut[snpQNeut$Pop != snpQNeut$Pop2,]
snpQNeut$Qval = p.adjust(snpQNeut$Pval, method = "BH")
head(snpQNeut)

snpHeatmapANeut = ggplot(data = snpFstNeut, aes(Pop, Pop2, fill = Fst))+
  geom_tile(color = "white")+
  scale_fill_gradient2(low = "white", high = "red", midpoint = 0, limit = c(0, 0.1),
                       space = "Lab", name = expression(paste(italic("F")[ST])))+
  geom_text(data = snpFstNeut, aes(Pop, Pop2, label = Fst), color = ifelse(snpQNeut$Qval <= 0.05,"black", "darkgrey"), size = ifelse(snpQNeut$Qval < 0.05, 6, 5)) +
  guides(fill=guide_colorbar(barwidth = 1, barheight = 12, title.position = "top", title.hjust = 0.5))+                     
  scale_y_discrete(position = "right")+
  scale_x_discrete(labels = str_wrap(snpFstNeut$Pop, width = 6)) +
  #ggtitle("   SNP") +
  theme_minimal()

snpHeatmapNeut = snpHeatmapANeut + theme(
  axis.text.x = element_text(vjust = 1, size = 16, hjust = 0.5, color = "black"),
  axis.text.y = element_text(size = 16, color = "black"),
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  legend.position = "right",
  legend.direction = "vertical",
  legend.title = element_text(size = 16),
  legend.text = element_text(size = 14),
  plot.title = element_text(size = 16)
)

snpHeatmapNeut

ggsave("../figures/snpHeatMapNeut.tiff", plot = snpHeatmapNeut, width = 34, height = 15, units = "cm", dpi = 300)
```

## SNPs potentially under selection
```{r, snps under selection}
genes = read.table("mcav_gene_regions.tab")
names(genes) = c("chromo","start","end","gene")

# expand gene regions Â± 2000 bp
genes$start = genes$start -2000
genes$end = genes$end +2000

gnames = read.table("mcav_gnames.txt", sep = "\t")
names(gnames) = c("gene", "protein")

genes = full_join(genes, gnames, by = "gene")
genes$protein=as.character(genes$protein)
genes$protein[is.na(genes$protein)]="unknown"

#how many annotated genes do we have?
nrow(genes[genes$protein!="unknown",])
head(genes)

snpLoci = read.table("fkMcavNoClones.mafs.gz", header = TRUE)
snpLoci$locus = c(1:nrow(snpLoci))

outsByGene = snpLoci %>% dplyr::select(locus, chromo, position) %>% 
  filter(locus %in% outs) %>%
  full_join(., genes, by = "chromo") %>% 
  filter(position>start, position<end)

outsByGene

#only show annotated genes
outsAnno = outsByGene %>% filter(protein != "unknown")
outsAnno

df_uniq <- unique(outsAnno$locus)
length(df_uniq)

write.csv(x=outsAnno, file="annotedOutliers.csv")

```
